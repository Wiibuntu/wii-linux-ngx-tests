--- drivers/usb/host/ohci.h
+++ drivers/usb/host/ohci.h
@@ -15,6 +15,28 @@
 typedef __u32 __bitwise __hc32;
 typedef __u16 __bitwise __hc16;
 
+/*
+ * Some platforms have weird constraints when accessing memory.
+ *
+ * For example, the Nintendo Wii video game console is unable to perform
+ * non-32 bit writes to non-cached memory for its second block of 64MB of RAM.
+ * As this platform also requires CONFIG_NOT_COHERENT_CACHE, all memory
+ * allocated using the dma memory allocation functions can only be written
+ * using 32-bit accesses.
+ *
+ * Because of this constraint, as a workaround, we make sure that all
+ * fields in struct ed and td (which are allocated from dma pools) are
+ * always 32 bit fields.
+ * Note that the remaining structs allocated from dma-able memory are already
+ * 32 bit fields.
+ */
+#ifdef CONFIG_USB_OHCI_HCD_HLWD
+#define ohci_fld(type)  u32
+#else
+#define ohci_fld(type)  type
+#endif
+
+
 /*
  * OHCI Endpoint Descriptor (ED) ... holds TD queue
  * See OHCI spec, section 4.2
@@ -52,21 +74,21 @@ struct ed {
 	/* create --> IDLE --> OPER --> ... --> IDLE --> destroy
 	 * usually:  OPER --> UNLINK --> (IDLE | OPER) --> ...
 	 */
-	u8			state;		/* ED_{IDLE,UNLINK,OPER} */
+	ohci_fld(u8)		state;		/* ED_{IDLE,UNLINK,OPER} */
 #define ED_IDLE		0x00		/* NOT linked to HC */
 #define ED_UNLINK	0x01		/* being unlinked from hc */
 #define ED_OPER		0x02		/* IS linked to hc */
 
-	u8			type;		/* PIPE_{BULK,...} */
+	ohci_fld(u8)		type;		/* PIPE_{BULK,...} */
 
 	/* periodic scheduling params (for intr and iso) */
-	u8			branch;
-	u16			interval;
-	u16			load;
-	u16			last_iso;	/* iso only */
+	ohci_fld(u8)		branch;
+	ohci_fld(u16)		interval;
+	ohci_fld(u16)		load;
+	ohci_fld(u16)		last_iso;	/* iso only */
 
 	/* HC may see EDs on rm_list until next frame (frame_no == tick) */
-	u16			tick;
+	ohci_fld(u16)		tick;
 
 	/* Detect TDs not added to the done queue */
 	unsigned		takeback_wdh_cnt;
@@ -126,7 +148,7 @@ struct td {
 	__hc16		hwPSW [MAXPSW];
 
 	/* rest are purely for the driver's use */
-	__u8		index;
+	ohci_fld(__u8)	index;
 	struct ed	*ed;
 	struct td	*td_hash;	/* dma-->td hashtable */
 	struct td	*next_dl_td;
@@ -406,6 +428,7 @@ struct ohci_hcd {
 	unsigned		restart_work:1;
 
 	unsigned long		flags;		/* for HC bugs */
+#define	OHCI_QUIRK_WII		0x1000			/* Hollywood chipset */
 #define	OHCI_QUIRK_AMD756	0x01			/* erratum #4 */
 #define	OHCI_QUIRK_SUPERIO	0x02			/* natsemi */
 #define	OHCI_QUIRK_INITRESET	0x04			/* SiS, OPTi, ... */
@@ -418,7 +441,6 @@ struct ohci_hcd {
 #define	OHCI_QUIRK_AMD_PLL	0x200			/* AMD PLL quirk*/
 #define	OHCI_QUIRK_AMD_PREFETCH	0x400			/* pre-fetch for ISO transfer */
 #define	OHCI_QUIRK_GLOBAL_SUSPEND	0x800		/* must suspend ports */
-
 	// there are also chip quirks/bugs in init logic
 
 	unsigned		prev_frame_no;
@@ -552,6 +574,37 @@ static inline struct usb_hcd *ohci_to_hcd (const struct ohci_hcd *ohci)
 #define big_endian_mmio(ohci)	0		/* only little endian */
 #endif
 
+#ifdef CONFIG_USB_OHCI_HCD_HLWD
+
+#include <asm/starlet-mini.h>
+
+static inline unsigned int _ohci_readl(const struct ohci_hcd *ohci,
+				       __hc32 __iomem *regs)
+{
+	return in_be32(regs);
+}
+
+static inline void _ohci_writel(const struct ohci_hcd *ohci,
+				const unsigned int val, __hc32 __iomem *regs)
+{
+	out_be32(regs, val);
+}
+
+extern void ohci_hlwd_control_quirk(struct ohci_hcd *ohci);
+extern void ohci_hlwd_bulk_quirk(struct ohci_hcd *ohci);
+
+#else
+
+static inline void ohci_hlwd_control_quirk(struct ohci_hcd *ohci)
+{
+	return;
+}
+
+static inline void ohci_hlwd_bulk_quirk(struct ohci_hcd *ohci)
+{
+	return;
+}
+
 /*
  * Big-endian read/write functions are arch-specific.
  * Other arches can be added if/when they're needed.
@@ -581,6 +634,8 @@ static inline void _ohci_writel (const struct ohci_hcd *ohci,
 #endif
 }
 
+#endif /* CONFIG_USB_OHCI_HCD_HLWD */
+
 #define ohci_readl(o,r)		_ohci_readl(o,r)
 #define ohci_writel(o,v,r)	_ohci_writel(o,v,r)
 
